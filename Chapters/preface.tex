\chapter*{Предисловие}
\markboth{\MakeUppercase{Предисловие}}{}
\addcontentsline{toc}{chapter}{Предисловие}

Отделы Компьютерных Наук многих университетов в качестве первого языка программирования обучают функциональному языку. Использование функционального языка с его высоким уровнем абстракции помогает подчеркнуть принципы программирования. Функциональное программирование --- это только одна из парадигм с которыми должен быть знаком студент. Также важны Императивное, Параллельное, Объектно-Ориентированное и Логическое программирование. В зависимости от решаемой задачи выбирается одна из парадигм как наиболее естественная парадигма для этой задачи.

Эта книга --- материал курса для обучения второй парадигме: \emph{императивному программированию}, используя C в роли языка программирования. В этой книге предполагается, что студент усвоил его первый курс функционального программирования на примере SML. Требованием книги является понимание принципов программирования: эта книга не нацелена на 'обучение решению задач' или 'программированию'. Эта книга нацелена на:

\begin{itemize}
\item{Знакомство читателя с \emph{императивным программированием} как другим способом реализации программ. Цель --- сохранить стиль программирования, то есть, программист думает функционально при реализации императивной программы.}

\item{Дать понимание \emph{различия между функциональным и императивным программированием}. Функциональное программирование --- это высокий уровень деятельности. Порядок вычислений и выделение хранилища является автоматическим. Императивное программирование, особенно в C, --- это низкий уровень деятельности, где программист контролирует и порядок вычислений и выделение хранилища. Это усложняет императивное программирование, но даёт императивному программисту возможности для оптимизации, не доступные для функционального программиста.}

\item{Познакомить читателя с \emph{синтаксисом и семантикой ISO-C}, особенно с мощью языка (в то же время подчёркивая что мощь может и убить). Мы посетим все тёмные переулки C, с \lstinline|void *| до арифметики указателей и присваиваний в выражениях. В отдельных случаях мы используем другие языки (такие как C++ и Pascal) для демонстрации концепций императивного программирования, не существующих в C. C был выбран из-за того, что он де факто стандарт в декларативном программировании и поскольку его низкоуровневая природа красиво контрастирует с SML. Те, кто хочет изучить, к примеру, Modula-2 или Ada-95 не должны столкнуться с большими трудностями.}

\item{Улучшить \emph{знания принципов программирования} и \emph{навыков решения задач}. Этому способствует использование трёх различных языков (математика, функциональный язык и императивный язык). Тот факт, что эти крайне различные языки имеют общие аспекты подтверждает существование принципов программирования и естественность их пользы.}

\item{Улучшить \emph{знания принципов абстракций}. Во всей книге мы призываем студента искать более абстрактные решения, например, изучая сигнатуру функции как абстракцию её цели используя как процедурные абстракции (в частности высокоуровневые функции) на ранней стадии, так и абстракции данных.}

\item{Провести студента от спецификации и математики до реализации и \emph{построения программного обеспечения}. В первых главах мы делаем акцент на написании корректных функций, когда мы достигнем успехов, то акцент будет постепенно смещён в трансформирование корректных функций в эффективные и многократно используемые функции. Чистый и ясный интерфейс имеет первостепенное значение, и только в крайних случаях он будет приноситься в жертву лучшей эффективности.}
\end{itemize}

Каждая задача в этой книге решается в три шага:

\begin{itemize}
\item{Создание спецификации задачи.}

\item{Нахождение соответствующего алгоритма, дающего решение, удовлетворяющее спецификации.}

\item{Реализация как можно более эффективного алгоритма. Акцент всей книги приходится на этот третий шаг.}
\end{itemize}

Язык математики используется для описания задачи. Сюда входят основы теории множеств и логики. Студент должен быть немного знаком с исчислением множеств, логикой предикатов и логикой высказываний. Этот материал преподают в большинстве университетов в течении первого курса дискретной математики или формальной логики.

Соответствующие алгоритмы даны в SML. SML свободно доступен для широкого числа платформ (персональные компьютеры, рабочие станции UNIX, Apple) поэтому он популярен в роли обучающего языка. Поскольку многие функциональные языки не сильно отличаются от SML, то в приложении дан краткий обзор SML для тех, кто знаком с другими популярными языками программирования, такими как Miranda, Haskell, Clean или Scheme.

Поскольку перед языком мы ставили цель реализовать решения в императивном стиле, то выбор был остановлен на C. Выбор в использовании C, а не C++ был труден. Оба языка популярны, и следовательно пригодны для использования. Мы выбрали C поскольку он более чисто определяет низкоуровневое программирование. Для иллюстрации рассмотрим механизм предоставляемый языком для вызова через ссылку. В C аргументы должны явно передаваться в виде указателя. Вызывающая сторона должна передать \emph{адрес}, а вызываемая сторона должна \emph{разыменовать} указатель. В контрасте этому находится механизм вызова через ссылку в C++ (и Pascal и Modula-2). Этот явный вызов через ссылку является дидактическим качеством, поскольку он явно описывает модель, стоящую за вызовом по ссылке и её опасности (в виде нежелательных псевдонимов).

Поскольку эта книга предназначена для использования на первом курсе, то количество требований, предъявляемых для студентов очень мало. Рассуждения о корректности программ требуют навыков доказательств, которые возможно ещё не выработались у студентов на данном этапе. Поэтому мы обозначили все упражнения с доказательствами специальной меткой. Упражнения требующие доказательств помечены астериском. Мы считаем что книгу можно использовать не выполняя ни единого доказательства. Однако, при втором чтении мы рекомендуем студентам выполнять доказательства. Ответы к одной трети упражнений даны в Приложении А.

Студент должен иметь понимание базовых принципов вычисления. Сюда входят арифметика второго уровня и принципы операций машины фон Неймана. Этому лучше всего соответствует курс компьютерных вычислений. Книга включает примеры из других областей информатики, включая базы данных, компьютерную графику, теорию языков программирования и компьютерную архитектуру. Эти примеры можно понять не обладая какими-либо предварительными знаниями в этих областях.

\section*{Благодарности}

Для нас очень важными были помощь и комментарии Хью Глэйзера (Hugh Glaser), Энди Грэйвелла (Andy Gravell), Лауры Лафев (Laura Lafave), Денис Николь (Denis Nicole), Питера Сестофта (Peter Sestoft) и анонимных читателей. Материал книги прошёл первое испытание в Саутгемптоне в 1995/1996 годах. Большое количество полезных отзывов пришло от студентов первого курса 1995 года набора, в частности от Джейсона Датта (Jason Datt) и Алекса Уолкера (Alex Walker).

В процессе работы над книгой мы использовали множество общественно доступных программных инструментов. Особенно полезными были: система грамотного программирования \lstinline|noweb| Нормана Рамси ({\selectlanguage{english}Norman Ramsey}), инструменты построения синтаксических диаграмм от L. Rooijakkers, \lstinline|gpic| от Брайана Кернигана (Brian Kernighan), \TeX, \LaTeX, New Jersey SML, и компилятор Gnu C.

Gnu C-compiler\texttrademark --- торговая марка Free Software Foundation.

IBM PC\texttrademark --- торговая марка IBM.

Macintosh\texttrademark --- торговая марка Apple Computer, Inc.

Miranda\texttrademark --- торговая марка Research Software Ltd.

UNIX\texttrademark --- торговая марка Novell.

Postscript\texttrademark --- торговая марка Adobe Systems, Inc.

\TeX\texttrademark --- торговая марка American Mathematical Society.

X Window System\texttrademark --- торговая марка MIT.


